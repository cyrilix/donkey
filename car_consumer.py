#! /usr/bin/env python
"""
Scripts to consume amqp messages generated by donkey car.

Usage:
car_consumer.py (-u USERID | --userid=USERID) --password=PASSWORD --hostname=HOSTNAME --path_root=TUB_PATH_ROOT [--topic=TOPIC]

Options:
-h --help                                       Show this screen.
-u USERID --userid=USERID                     Amqp user
-P PASSWORD --password=PASSWORD                 Amqp password
-H HOSTNAME --hostname=HOSTNAME                 Server host
-p TUB_PATH_ROOT --path_root=TUB_PATH_ROOT  Path where to write messages
-t TOPIC --topic=TOPIC                          Topic name [default: fous_du_volant]

"""
import base64
import json
import logging
import os
from os import path
from pathlib import Path

import paho.mqtt.client as mqtt
from docopt import docopt

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


def run_consumer(hostname, topic, userid, password, tub_path_root):
    consumer = Consumer(tub_path_root=tub_path_root)

    def on_connect(client, userdata, flags, rc):
        logger.info("Connected with result code %s", rc)
        client.subscribe(topic, qos=1)

    def on_message(client, userdata, msg):
        consumer.run(msg)

    mqtt_client = mqtt.Client(client_id='car_consummer-',
                              clean_session=False, userdata=None,
                              protocol=mqtt.MQTTv311)
    mqtt_client.username_pw_set(username=userid, password=password)
    mqtt_client.connect(host=hostname)
    mqtt_client.on_connect = on_connect
    mqtt_client.on_message = on_message
    mqtt_client.loop_forever()


class Consumer:

    def __init__(self, tub_path_root):
        self._tub_path_root = tub_path_root

    def run(self, message: mqtt.MQTTMessage):
        msg = json.loads(message.payload.decode('utf-8'), encoding='utf8')
        logger.debug('Received a message: %s', msg['application_headers'])

        tub_path = self._mkdir_tub(msg['application_headers'])
        if msg['content_type'] == 'application/json':
            part = 'record'
        else:
            part = msg['application_headers']['part']

        file_ext = msg['application_headers']['name'].split('.')[-1]
        file_name = '{0}/{1}_{2}.{3}'.format(tub_path,
                                             part,
                                             '{:09d}'.format(msg['application_headers']['index']),
                                             file_ext)
        print(str(msg['application_headers']['index']) + '                  ', end='\r')

        self._write_content(file_name, msg)

    @staticmethod
    def _write_content(file_name: str, msg: dict):
        Path(file_name).parent.mkdir(parents=True, exist_ok=True)
        if msg['content_type'] == "application/json":
            logger.debug('Content: %s', msg['payload'])
            with open(file_name, encoding='utf-8', mode='wt') as json_file:
                json_file.write(json.dumps(msg['payload']))

        if msg['content_type'] == "image/jpeg":
            with open(file_name, mode='wb') as image_file:
                image_file.write(base64.standard_b64decode(msg['payload']))

    def _mkdir_tub(self, application_headers):
        tub_path = path.join(self._tub_path_root, application_headers['tub_name'])
        os.makedirs(tub_path, exist_ok=True)
        return tub_path


if __name__ == '__main__':
    args = docopt(__doc__)
    run_consumer(hostname=args['--hostname'],
                 topic=args['--topic'],
                 userid=args['--userid'],
                 password=args['--password'],
                 tub_path_root=args['--path_root']
                 )
